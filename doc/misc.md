* mbr <https://zh.wikipedia.org/wiki/主引导记录>
* nasm <https://www.nasm.us/doc/>

## memory segmentation

如果没有分段机制, 任何程序直接访问绝对地址, 会有什么问题
* 一个程序地址总是硬编码的, 如果想稍微换个加载地址, 那么整个程序的各个引用地址基本都要更改
* 如果想把多个程序放到内存里, 一个程序特别容易侵犯另一个程序的地址空间

我们很自然希望不同程序的地址隔离, 每个程序一段, 老死不相往来

而让人来解决这件事耗费心力, 限制程序复杂度: 要么交付给编译器实现, 要么从下游硬件端彻底解决

通过 "段寄存器+段偏移寄存器" 实现重定位
* 让程序多了个可重入的属性, 只要我的段寄存器是对的, 那么相对引用地址的偏移就是正确的, 也就是程序换个地方依然能跑
* 另外 intel 顺带也通过分段机制来拓展地址空间, 让 16 位地址总线能有 20 位地址空间

但这种机制并没有改变程序直接可以相互侵犯的本质, 要解决这一点, 必须引入特权机制, 而出于历史遗留问题, intel 的特权机制最初也建立在分段的基础上

<!-- 不过 8086 之前, 设计上没提供方便重定位的手段, 这在当时算是革命性进步 -->

## program segmentation

为什么要把程序的分成代码段/数据段
* 逻辑更清晰
* 设置不同的属性(访问权限)
* 提高 cache 命中
* 不同进程通过共享代码段(只读)节省内存
* 匹配分页机制, 提高效率

谁来分段
* 高级语言编译器(链接器)
* 汇编往往要要手动分段
* 借助 ldscript

不同段的属性是如何设置并生效的 (x86)
* 编译器会将代码编译成段序列 (e.g. elf 格式)
* os 准备 gdt 表, 并控制程序加载的过程
* 用户程序在 cpu 下是低特权级, 用段选择子访问时, 如果有非法读写等行为, 会被拦截 (引发中断)

80386 的内存模型 <https://zhuanlan.zhihu.com/p/48773628>
* 平坦模式: 整个内存分为一段, 段基址为 0, 一般结合分页机制
* 分段模式: 通过选择子查找段基址 + 偏移地址
* 实模式: 向后兼容 8086 模式, 段基址 + 偏移地址

section & segment
* 汇编语境下: 两者一个意思, 逻辑区域
* os 不关心 section 的数量, 只关心属性, 所以链接器将同属性的 section merge 到一起, 称为 segment
* segment 也就是内存中所谓的代码段, 数据段

## nasm vstart
* `align=16`: 段地址是 16 字节对齐的, 显然和 ia-32 内存分段的机制相关
* `vstart=0`: 程序的虚拟起始地址, 用来计算在该 section 内的所有内存引用地址
* 汇编器会期望把程序加载到 `vstart` 处, 你当然可以加载到别的地方, 但程序引用的地址可能会不正确

section 的有无本身其实对编译后的程序地址没有任何影响, 关键在 `vstart`
* `$` 和 `$$` 是根据 `vstart` 来计算得到的绝对值
* `section.data.start` 则不受 `vstart` 影响, 是相对值

## interrupt
> intel 术语: cpu 内叫异常, 外设叫中断

BIOS 中断
* 中断向量表 (IVT) 指向的例程 (共 1024B/4B 项), 实际就由 BIOS 设置
* 实际 IVT 指向的例程地址是固定的, BIOS 只能修改指向的内容
* 实模式下我们可以调用 IVT, 每项是指向一个中断例程地址

DOS 中断
* DOS 本身运行在实模式下, 所以可以调用 BIOS 的中断
* DOC 建立一个自身的中断 0x21

Linux 中断
* 此时已经在在保护模式下, IVT 不存在, 而是访问 IDT (中断描述符表)
* 惯例用 int 0x80 + exa 来确定子功能函数

## I/O interface

I/O 接口是硬件的一种协议, 是 cpu 访问硬件资源的接口 (硬件的代理)
* 任何不兼容的问题, 都可以加一层来解决
* <https://en.wikipedia.org/wiki/Memory-mapped_I/O_and_port-mapped_I/O>
* <https://www.cnblogs.com/beixiaobei/p/10608356.html>

软件视角
* MMIO: 将硬件的功能映射到地址空间, "访存"
  * `sudo cat /proc/iomem`
* PMIO: 将硬件的功能映射到特殊的寄存器
  * `sudo cat /proc/ioports`
* 可编程/不可编程 接口芯片

硬件视角
* IO 接口连接 CPU 和其他硬件的逻辑控制部件
  * 比如声卡, 显卡, 一般集成在主板里, 分别驱动音响和显示器
* 分层: cpu 和硬件两方, 各自只要实现好自己的功能, 中间由 IO 作为 桥梁, 解决兼容问题

仲裁 IO: 当很多外设都想和 CPU 通信, 负责协调好顺序
* 南桥主要用来连接低速设备 pci, pci-express, agp
  * 内部集成了很多 IO (SATA, USB, PCI...)
* 北桥芯片: 一般和南桥成对出现, 连接高速设备(内存), 或集成到 CPU 里

![south:bridge](http://img.phanium.top/20230409151002.png)

## magic number

本质不过是一种简单的约定/协议
* 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
* 0x55 0xaa: 可加载/可引导
  * ROM 检查: BIOS 在运行期间会扫描 0xC0000 到 0xE0000, 若在某个区域发现前两个字 节是 0x55 和 0xAA 时
  * 这意味着该区域对应的 rom 中有代码存在, 再对该区域做累加和检查, 若结果与第 3 个字节的值相符, 说明代码无误, 就从第 4 个字节进入.
  * 这时开始执行了硬件自带的例程以初始化硬件自身, 最后, BIOS 填写中断向量表中相关项, 使它们指向硬件自带的例程
* 文件系统识别, 一般位于本分区的第 2 个扇区 (1 号扇区为 superblock)

mbr 为啥在 0x7c00
* IBM 5150 运行的 DOS 1.0 要求的最小内存 32KB = 0x8000B
* mbr 本身要给前面的应用留足空间, 运行时又得有自己的栈
* 方案是为 mbr 预留 1k 放到末尾 (0x8000 - 1K = 0x7c00)

## library
* 操作系统: 实现系统调用, 隔离硬件接口
* 库函数: 封装成 API, 提供运行时库
* 用户程序: 链接运行时库, 使用库函数, 也可以直接使用 int 0x80

函数为什么要声明
* 确定函数返回值类型, 参数类型及个数, 用来确定分配的栈空间
* 分解出链接的步骤: 符号解析 + 重定位, 现在无法得知地址, 之后重定位

## legacy boot
* 上电 RESET, 跳转到 BIOS, 搜索执行硬件初始化例程, 设置 IVT, 加载并跳转到 MBR
  * MBR 位于 0 盘 0 道 1 扇区, 内容为 446 + 64 + 2
* 解析分区表, 可能同时有主分区和拓展分区下的逻辑分区, 搜索并选择跳转道活动分区 (表项开始为 0x80)
* 通过活动分区跳转到 osloader
```
f000:fff0 -> f000:e05b (BIOS) -> ... -> 0000:7c00 (MBR)
MBR -> 活动分区 -> osloader
```

MBR OBR DBR EBR 都包含引导程序, 都称为引导扇区
* 分区表只在 MBR 和 EBR 中存在
* DOS 时代, 至多只有 4 个分区: MBR -> DBR(OBR)
* 后来拓展分区出现, EBR 的分区表可以再分逻辑分区
![mbr](https://i.imgur.com/FXFG1kj.png)

## cpu
* 控制单元: 操作控制器, 指令寄存器, 指令译码器
* 存储单元
* 运算单元

![cpu](https://i.imgur.com/OnMMDPT.png)
