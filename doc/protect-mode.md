## 保护模式
- <https://sunra.top/posts/43690/>
- 实模式下: 用户和内核权限相同, 访存纯物理地址, 用户随便访问指哪打哪, 不安全
- 抢占式多任务没法实现, 现在还没有中断机制, 一次只能跑一个任务, 而且就算实现协作式多任务, 不同任务之间的地址压根就不是隔离的, 简直是笑话

> 实模式是 80386 的概念: 特指 32 位 CPU 运行在 16 位模式的状态, 和纯粹的16 位CPU, 如8086 等无关


## 寄存器拓展
- 32 位 gpr + 16 位 sreg (存 selector)
- descriptor cache, 也用于 cache 实模式下移位后的段地址
> 在保护模式下加载选择子(即使新选择子的值和之前段寄存器中老的选择子相同), CPU 就会重新访问全局描述符表, 再将获m的段信息重新放回段描述符缓冲寄存器, 或在实模式下为段寄存器赋予段基址, 无论是否与之前段基址相同, 段基址左移 4 位后的结果就被送入段描述符缓冲寄存器
![img:desciptor-cache](https://i.imgur.com/kZqSd4T.png)

> 80286: 16 位 reg, 白白浪费了 24 位段基址的优势

## 寻址拓展
![img:addressing](https://i.imgur.com/BZY53dI.png)
```asm
mov axm[si]
mov ax,[di]
mov ax,[bx]
mov ax,[bx+si]
mov ax,[bx+si+0x1234]
mov ax,[bx+di]
mov ax,[bx+di+0x1234]
```

## 运行模式反转

> 80386 实模式能 "利用" 保护模式的资源

指令格式
```
前缀 操作码 寻址方式/操作数类型 立即数 偏移量
```

CPU 的指令集专门设计了一种前缀, 用于反转, 只要机器码加上这种前缀, 一种模式下就能使用一些另一种模式的指令

如果要加上前缀, 说明这就不算本模式的指令了, 更底层上这种指令肯定用到了"不属于"自己的资源 (比如 reg, 默认的操作数位长)

nasm 汇编器语法
- `[bits 16]` 下面的代码帮我编译成 16 位的机器码
- `[bits 32]` 下面的代码帮我编译成 32 位的机器码

汇编器为什么不能自动区分出保护模式
- 进入保护的方式是千奇百怪的, 比如: 先打开 a20 -> 加载 gdt -> 设置 cr0 的 pe 位, 每个步骤可以继续拆分, 其中顺序甚至可以打乱
- 此时显示告诉编译器运行模式是什么, 然后编译器再判断需不需要加入前缀, 成本反而低一点


prefix 0x66: 反转 (默认) 操作数大小
- 实模式下, `mov eax, 0x1234`, 用到了不属于自己的寄存器, 要反转默认的操作数大小, 来 fit 这个寄存器
- 反过来, 保护模式用到 ax 也被认为 是越俎代庖... 不过你只要提供合适的操作数就行, (会不会被 cut 掉)

prefix 0x67: 反转 寻址方式
- 实模式下, `mov word [eax], 0x1234`, `eax` 不是自己寻址方式下的位宽, 翻转到保护模式的寻址方式

复合 prefix
- 实模式下, `mov dword [eax], 0x1234`
- dword 隐含了操作数默认位长要反转

## 指令拓展

寄存器拓展派生出新位长指令
```
add al, cl
add eax, ecx
```

重点说一下 mul
```asm
mul cl # ax = cl * al
mul cx # eax = cx * ax
mul ecx # edx:eax = ecx * eax
```

> 等下这跟实模式不一样啊...
> 既然实模式能用保护模式的指令, 而之前的 16 位乘法, 结果存在 dx:ax 里...

对于无符号数除法指令div, 其格式是div 寄存器/内存, 其中的"寄存器/内存"是除法计算中的除数.
- 如果除数是8 位, 被除数就是16 位, 位于寄存器ax. 所得的结果, 商在寄存器al, 余数在寄存器ah.
- 如果除数是16 位, 被除数就是32 位, 被除数的高16 位则位于寄存器dx, 被除数的低16 位则位于
    寄存器ax. 所得的结果, 商在寄存器ax, 余数在寄存器dx.
- 如果除数是32 位, 被除数就是64 位, 被除数的高32 位则位于寄存器edx, 被除数的低32 位则位于
    寄存器eax, 所得的结果, 商在寄存器eax, 余数在寄存器edx

push
- 实模式
    - 8 位, 拓展成 16 位 (sp-2)
    - 16 位, 正常 (sp-2)
    - 32 位, 模式反转 (sp-4)
- 保护模式
    - 8 位, 拓展成 32 位 (sp-4)
    - 16 位, 模式反转 (sp-2)
    - 32 位, 正常 (sp-4)
- 段寄存器: 实模式 16 位, 保护模式 32 位
```sh
push ax
push eax
push word [0x1234]
push dword [0x1234]
```

## 全局描述符表 GDT

> gdt (段表) 描述内存中的各个段的属性, 包括从哪里开始, 到哪里结束

- gdt 本身存储在内存里面, gdtr 存储 gdt 的初始地址, 用 lgdt 来初始化
- 段寄存器存储选择子, 13 索引 + 1 (gdt/ldt) + 2 位特权级
- 提供索引 -> gdt 查询 -> 返回段地址 -> 段地址 + 偏移地址 = 访存地址

局部描述符表 ldt
- 不是很重要, 简单说就是希望硬件能原生支持多任务而设计的, 一个任务对应一个 ldt, 这样就原生隔离了
- 和 gdt 很像: ldtr, lldt, 但 ldt 0 索引可用

gdt 的 0 索引处不可用
- 如果段选择子忘了初始化, gdt 访问的时候是全 0 的, 这样干脆禁止索引为 0, 发出一个异常提醒你可能是忘了初始化
- 而如果是 ldt 访问, ti 位一定会显式设置 1, 这样不太可能忘记把选择子也初始化, 这么说感觉有一定道理

> 中断描述符表 idt: 定义中断门, 陷阱门, 任务门


开关: CR0 的第 0 位, PE 位(protection enable)

段描述符
![img:seg-descriptor](https://i.imgur.com/pMsjyQa.png)
- `段界限边界值= (描述符中段界限+1)*(段界限的粒度大小: 4KB 或者1)-1`
- 段界限粒度大小为 4KB 字节

字段:
- s type a c dpl p
- x r c a
    - conforming: 如果该段是 jmp 的目标段, 那么该段特权级一定要高于 jmp 前的段的特权级, 同时如果 jmp 成功, 那么之后执行流的特权级应该不是 DPL 决定, 而是 遵从 jmp 前的特权级
    - 有种 setuid 的感觉
- x w e a
    - extend 栈的方向哪里拓展 0 上 1 下

## 处理器微架构

流水线

乱序执行
- CISC RISC 和 二八定律
- CISC 各个操作比较复杂, 容易相互关联, 不好乱序执行
- 后期的 0x86 虽然是 CISC 指令集, 但内部已经采用 RISC 内核, 而 RISC 操作比较微小, atom, 通常独立无关联, 因此适合乱序执行

缓存
- 寄存器和缓存差不多快的
- 局部性: 时间, 空间

分支预测
- 流水线 fetch 如果遇到分支, 会进行预测, 选择一条路径去预取
- 这种操作的合理性在于: 只要不到执行, 实际上对我的执行流是没有影响的, 就算预测错了, 我可以刷新流水线来扔掉预取的指令
    - 而如果不预测, 流水线只能卡着不动, 浪费很大
- 问题: 如何来预测, 流水线级数越大, 如果预测错了, 代价也会越大

naive 的预测: 2 位预测法
- 用 2 bit counter 来记录跳转状态, 每跳转一次就加 1,  直到加到最大值 3 就不再加; 如果未跳转就减 1, 直到减到最小值 0 就不再减了
- 当遇到跳转指令时,  如果计数器的值大于 1 则跳转;  如果小于等于 1 则不跳.

BTB 缓冲
- btanch target buffer
- 是一个表, 每项为 分支地址+预测分支+跳转统计
- 每次到分支, 先查表, 根据表的统计信息, 决定如何预测
- 表中没有, 则 fallback 到静态预测 (static predictor)


## 保护内存段

保护模式是如何对内存进行保护的?
本质上是访问控制

<!-- 主要分两步 -->
<!-- - 首先保证访问的 GTP 的表项是合法的 (也就是段本身是合法的, 或者说基地址是合法的 -->
<!-- - 其次保证, 访问段的时候不能跨段, (也就是具体的地址是合法的 -->

首先, 访问控制, 从加载选择子的时候就发生了

如果能随便加载选择子到 sreg, 那么保护模式保护个鸡毛

向 段寄存器(cs, ss, ds...) 加载 选择子 的过程
- 检查 index: gdt_base + selector_index * 8 + 7 <= gdt_base + gdt_limit
    - 如果 TI 是 1, 则比的是 ldt
- 检查 type, 有一些规则如下
    - 有 x 才能 load 到 cs, 同时只 x 不能 load 到其他
    - 有 w 才能 load 到 ss
    - 有 r 才能 load 到 ds, es, fs, gs
- 检查 P
    - 如果不在内存, 处理器先来个抛出异常, 自动处理异常, 取到内存, 然后 CPU 指令
    - 取到之后, 一般由 OS 设置 P = 1 (CPU 是设置 A)

完成上述步骤, 选择子就可装到 sreg 里, 同时 段描述符缓冲寄存器(也是 64 位) 会更新为相应的段描述符的内容

对代码段和数据段的保护
- 拿到段地址后, 每当去真正访问一个地址, CPU 会确认, 地址不能超过 段描述符的范围
- 这个时候其实就不用检查段地址了, 只检查偏移地址
- 数据段: off_addr + data_len - 1 <= 实际段界限: (sd_limit + 1) * granularity - 1
- 代码段: off_addr + inst_len - 1 <= 实际段界限: (sd_limit + 1) * granularity - 1
- Q: 而对于栈....
    - e, 向上增长和向下增长?
    - 如果栈是向上增长
    - 实际段界限 <= esp - 操作数 <= 0xffff_ffff

## 获取物理内存容量

linux 的 `detect_memory`, BIOS 0x15
- eax = 0xe820, 所有内存
    - 内存布局, dmesg
    - 迭代式查询, 每次只返回一种类型的内存
    - 返回格式: ARDS(base + len + type)
- ax = 0xe801, 最大 4G
- ah = 0x88, 最大 64MB

BIOS 中断是实模式下的方法, 只能在进入保护模式前调用
- 那么我们设计, 在实模式调用得到内存信息后, 再进入保护模式

ARDS 格式(address range desciptor structure)
- 共 20 字节, 每个字段 4 字节
- 前 16 字节: base low, base high, len low, len high(单位是 bytes)
- 最后 4 字节: type, 标记是否内存可被 OS 使用
    - 为什么可能不能使用? 比如: 系统 ROM, ROM 用到的内存, 设备内存映射, 特殊原因不适合标准设备使用等等


## BIOS 0x15

如何调用 BIOS 中断呢, 我们详细看看 0x15 的 spec

子功能号 eax=0xE820
- 其他输入
    - ebx ARDS 后续值(类似 next 指针的作用, 初始置 0, 后续不用管)
    - es:di 为输出准备的缓冲区
    - ecx 指定要输出的 ARDS 结构的字节大小(20 字节?)
    - edx 固定签名, "SMAP" 的 ASCII 码 0x534d4150 (S 是寄存器高位)
- 输出
    - cf 表明是否出错
    - es:di ARDS 的内存信息
    - eax "SMAP"
    - ecx 实际写入的 ARDS 字节数
    - ebx 后续值

子功能号 ax=0xE801
- 输入: 就只有 ax
- 输出
    - cf 是否出错
    - ax = cx, 单位 1KB, 15MB 以下的内存(最大 0x3c00 * 1024 = 15MB)
    - bx = dx, 单位 64KB, 16MB - 4GB 的连续单位, bx * 64 * 1024
- 为什么分两部分, 15MB-16MB 去哪了?
    - 如果你实际在内存大于等于 16 MB 的主机上尝试会发现, ax*1024+bx*64*1024 得到的结果正好比实际的少 1MB, 原因在于 BIOS 中断不会把这 1MB 算在里面
    - 祖传问题来源: 80286 寻址空间正好 16MB, 当初拿了 15MB - 16MB 去映射 ISA 设备, 后面就一直保留了, 形成了内存空洞(memory hole)
    - 不过现在 BIOS 可由用户选择是否开启
- 为什么有冗余, ax=cx, bx=dx? 鬼知道, 两个字段可能是不同含义, 不过结果的值恰好是相等的

子功能 ah=0x88
- 只显示 1MB 以上的内存量, 且最多到 64MB (也就是最大返回 63MB)
- 输入 ah, 输出 cf, ax (1KB 单位)

